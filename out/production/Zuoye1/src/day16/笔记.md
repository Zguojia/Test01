### 线程状态概述
    1.NEW(新建)：线程刚被创建，但是并未启动。还没调用start方法。
    2.Runnable(可运行)：线程可以在java虚拟机中运行的状态，可能正在运行自己代码，也可能没有，这取决于操作系统处理器。
    3.Blocked(锁阻塞)：当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态；当该线程持有锁时，该线程将变成Runnable状态。
    4.Waiting(无限等待)：一个线程在等待另一个线程执行一个（唤醒）动作时，该线程进入Waiting状态。进入这个状态后是不能自动唤醒的，必须等待另一个线程调用notify或者notifyAll方法才能够唤醒。
    5.Timed Waiting(计时等待)：同waiting状态，有几个方法有超时参数，调用他们将进入Timed Waiting状态。这一状态将一直保持到超时期满或者接收到唤醒通知。带有超时参数的常用方法有Thread.sleep 、Object.wait。 
    6.Teminated(被终止)：因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。

###Waiting
    无线等待一定需要被唤醒，否则一直等待；
    如果有时间限制，比如5000，在这个期间如果有被唤醒，则直接醒来，如果没有则一直等到5000；

###public final void wait()：
    让当前线程进入等待状态(并不是当前线程对象来调用,而是当前锁对象来调用) 调用wait()之后释放当前锁,并且让当前锁对象中对应的线程阻塞. 
    因为wait需要释放锁，所以必须在synchronized中使用
    wait方法与notify方法必须要由同一个锁对象调用。    
    wait方法与notify方法是属于Object类的方法的。
    wait方法与notify方法必须要在同步代码块或者是同步函数中使用。
    
###public final void notify() ：
    随机唤醒一条此锁对象对应线程中的一条.notify()也是锁对象来调用,并不是当前线程对象调用
    notify()：唤醒在当前锁对象中随机的一条线程。
    notifyAll()：唤醒当前锁对象对应的所有线程(效率低)。
    
###sleep和wait方法的区别？
    sleep():必须传入睡眠的时间毫秒值,和毫秒值加纳秒值
    wait():可以不用指定时间,如果指定时间代表线程不会立马等待,而是指定时间过后再等待
    sleep():在休眠指定时间后自动醒来,并且休眠时间不释放锁
    wait():等待过程中不会自动醒来,而是调用notify()方法来唤醒,并且调用时里面释放锁
    wait()方法必须是锁对象来调用，而且必须是在同步代码块中执行，否则会出现IllegalMonitorStateException异常

###线程池概念
    线程池：其实就是一个容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。
    
###线程池的特点
    1. 降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。
    2. 提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。
    3. 提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。

###使用线程池中线程对象的步骤：
    1. 创建线程池对象。
    2. 创建Runnable接口子类对象。(task)
    3. 提交Runnable接口子类对象。(take task)
    4. 关闭线程池(一般不做)。



    